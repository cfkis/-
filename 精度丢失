原因：计算机的二进制实现和位数限制有些数无法有限表示。

js采用IEEE754规范，采用双精度存储，占用64bit。

1位表示符号位
11位表示指数
52位表示尾数

解决：
对于整数，前端出现问题的几率可能比较低，毕竟很少有业务需要需要用到超大整数，只要运算结果不超过 Math.pow(2, 53) 就不会丢失精度。

对于小数，前端出现问题的几率还是很多的，尤其在一些电商网站涉及到金额等数据。

解决方式：把小数放到位整数（乘倍数），再缩小回原来倍数（除倍数）。

/**
 * num 要处理的小数
 * fix 保留小数位数
 * return 正确精度的小数
 **/
function toFixed (num, fix) {
  // num 的 fix 次幂
  const times = Math.pow(10, fix)
  // 转整数
  r = num * times
  // 再转回小数
  let r = Math.round(r) / times
  return r
}
